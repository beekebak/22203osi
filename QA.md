|Вопрос|Ответ|
|------|------|
|что делает pthread_exit()|На уровне ядра существует структура Task, в ней есть специльное поле для возвращения значения. Pthread_exit() завершает поток и копирует значение в это поле.|
|в какой момент завершается процесс(с pthread_exit() и без)|Процесс завершается когда завершаются все потоки. У каждого потока есть функция-обертка, которая вызывает функцию, переданную пользователем. Она как раз и занимается менеджментом жизненного цикла.|
|как создается поток(в т.ч. что делает pthread_create())|Создается новая структура Task, на новый стек копируются переданные переменные, запускается функция-обертка, возваращется значение tid в user-space.|
|что очищается pthread_join()|pthread_join() очищает Task, который должен ждать этого join, если поток не является detached, иначе поток очистится и так.|
|где хранится возвращаемое 42|В поле структуры на уровне ядра.|
|524227 потока и все почему|Как-то связано с размеров стека, максимальной памятью одного процесса, размером Task, но у меня не сошлась математика :(|
|с detached можно больше почему|Detached потоки чистятся по ходу выполнения программы, после выполнения пользовательской фунции, память восстанавливается.|
|что будет если поток завершится до pthread_detach()|Ничего страшного, pthread_detach() просто почитстит ресурсы|
|передача параметров как происходит, где хранятся|Не делал еще|
|можно ли printf и free в потоках, нужна ли синхронизация|В glibc можно, в рандомной реализации printf нельзя: free() можно всегда, функция не использует общие ресурсы(если использует то UB). Printf использует общий вывод буфера и не обязан быть потокобезопасным, но стандарт POSIX требует потокобезопасность многих функций(в том числе printf()). Любая реализация стандартной библиотеки C (glibc в т.ч.) для того, чтобы соотвествовать POSIX должна делать printf() потокобезопасным.|
