|Вопрос|Ответ|
|------|------|
|Почему sleep() не сработает для фикса первой программы?|Самое простое - поточная функция будет работать дольше, чем указано в sleep, и поток тупо не успеет завершиться нормально. Еще есть голодание потоков - это когда при высокой нагрузке на систему новый поток не может получить доступ к ресурсам, в итоге время между созданием и запуском может возрастать.|
|что делает pthread_exit()|На уровне ядра существует структура Task, в ней есть специльное поле для возвращения значения. Pthread_exit() завершает поток и копирует значение в это поле.|
|в какой момент завершается процесс(с pthread_exit() и без)|Процесс завершается когда завершаются все потоки. У каждого потока есть функция-обертка, которая вызывает функцию, переданную пользователем. Она как раз и занимается менеджментом жизненного цикла.|
|как создается поток(в т.ч. что делает pthread_create())|Создается новая структура Task, на новый стек копируются переданные переменные, запускается функция-обертка, возваращется значение tid в user-space.|
|что очищается pthread_join()|pthread_join() очищает Task, который должен ждать этого join, если поток не является detached, иначе поток очистится и так.|
|где хранится возвращаемое 42|В поле структуры на уровне ядра.|
|524227 потока и все почему|Как-то связано с размеров стека, максимальной памятью одного процесса, размером Task, но у меня не сошлась математика :(|
|с detached можно больше почему|Detached потоки чистятся по ходу выполнения программы, после выполнения пользовательской фунции, память восстанавливается.|
|что будет если поток завершится до pthread_detach()|Ничего страшного, pthread_detach() просто почитстит ресурсы|
|передача параметров как происходит, где хранятся|Не делал еще|
|можно ли printf и free в потоках, нужна ли синхронизация|В glibc можно, в рандомной реализации printf нельзя: free() можно всегда, функция не использует общие ресурсы(если использует то UB). Printf использует общий вывод буфера и не обязан быть потокобезопасным, но стандарт POSIX требует потокобезопасность многих функций(в том числе printf()). Любая реализация стандартной библиотеки C (glibc в т.ч.) для того, чтобы соотвествовать POSIX должна делать printf() потокобезопасным.
|где хранится аргумент, передаваемый в функцию?|аргумент хранится в локальной переменной функции-обертки, потом передается в пользовательскую функцию при запуске|
|почему данные в куче?|если хранить данные на стеке, то при выходе из функции память деинициализируются, поскольку стеки не разделяются потоками. Тогда функция во втором потоке обратится по деинициализированной памяти|
|как работает pthread_cancel?|pthread_cancel() посылает запрос отмены потоку, который тот может обработать(завершить работу) или проигнорировать.(man pthread_cancel)|
|где обрабатывается запрос?|дефолтно, запрос обрабатывается в функциях(список в man pthreads, есть одна, которая специально для создания cancellation points)(man pthread_cancel)|
|какие недефолтные настройки?|недефолтно, поток может игнорировать запросы pthread_cancel(), тогда они будут копиться в очереди. Еще он можем обрабатывать запросы как можно быстрее, а не только в cancellation points(man pthread_cancel)|
|что делает поток после обработки pthread_cancel?|вызывает функции со стека очистки(pthread_cleanup), вызывает деструкторы для глобалок и статических переменных потока, завершает поток(man pthread_cancel)|
|что за функции очистки?|есть функции pthread_cleanup_pop/push(в pthread_cleanup_push есть аргумент (void* arg), который можно передать в функцию), которые позволяют добавить функции-обработчики на выход из потока(при помощи pthread_cancel, pthread_exit). Отдельную функцию можно вызвать, убрал ее со стека pthread_cleanup_pop(arg), если arg != 0.(man pthread_cleanup_push)|
|что за глобалки и статические переменные потока?|иногда нужно, чтобы глобальный(статические) переменные были локальными для какого-то потока, для этого используется TSD(thread-specific data) area, пространство в памяти потока, изначально пустое, в которое можно добавить данные в виде указателя на данные, также привязав функцию-деструктор. Их можно удалить после. Функции вызовутся после выхода через pthread_cancel или pthread_exit. Ключей ограниченное количество(PTHREAD_KEY_MAX). Когда функция вызывается, она делает свой указатель на свой ключ NULL, если инициализировать в функции заново, это вызовет рекурсию. Glibc обходит такие рекурсии при помощи константы, которая ограничивает количество вызовов функций-деструкторов (man pthread_key_create)|
|Что за пустые места между памятью для стеков новых потоков?|Это guard page - маленький кусочек памяти без разрешений на запись или чтение (---p). Он расположен под стеком. Когда указатель на вершину потока уходит вниз (то есть стек растёт в объёме), он может попасть в guard page стека, и тогда при попытке обратиться в память, где нет прав чтения и записи, генерируется исключение. Обработчик исключений смотрит, где вершина стека, и если она действительно попала в guard page стека, то стек увеличивается, а сама guard page сдвигается вниз, предоставляя доступ к новой зарезервированной памяти для стека (то есть память для стека используется сразу не вся). В общем, guard page нужна для того, чтобы указатель на вершину стека не вылетел туда, куда ему не надо, и при этом корректно сдвигалась вниз для увеличения объёма.|
|Что происходит при join, как заблокированный поток понимает, что нужно продолжить работу?|Когда joined-поток завершается, он ставит флажок для того, кто сделал join|
|как pthread_cancel() переносится в нужный поток?|в структуре потока в ядре есть специальный флаг, значение которого проверяется, чтобы узнать, был ли поток отменен. Сигналы не используют>
|что будет если в обработчике pthread_cleanup_push добавить еще обработчик?|бесконечная рекурсия, стек оверфлоу(на стек добавляются новые функции, а старые не завершаются)|
|что будет если в обработчике pthread_cleanup_push вызвать pthread_exit?|бесконечная рекурсия, без стек оверфлоу(новых функций не добавляется, только переход на уже существующую)|
|что такое сигналы?|механизм асинхронного взаимодействия процессов, поддерживаемый ОС|
|жизненный цикл сигнала?|сигнал появляется, потом он добавляется(осью) в очередь целевого процесса(либо игнорируется, либо блокируется пока не сможет быть добавлен в очередь), когда происходит переключение контекста процесс проверяет сигналы, пришедшие к нему, обрабатывает их|
|как процесс может обработать сигнал?|у каждого сигнала есть стандартный обработчик(завершить процесс, завершить+дамп, проигнорировать, остановить, продолжить), либо можно заменить на свой обработчик|
|все ли сигналы можно обработать самому?|нет, SIGKILL и SIGSTOP не перехватываются и не обрабатываются пользователем|
|почему есть несколько способов обработать сигнал?(2 сисколла)|signal(2) deprecated, поскольку он работает по разному для разных версий си(GNU, BSD), связанно это с существованием двух разных реализаций сигналов(GNU, BSD)|
|что такое маска сигналов?|поток может блокировать/не блокировать получение сигналов, для этого используются 2 маски, в которую выставляется биты для того, чтобы поток знал, что нужно принимать/блокировать|
|если в процессе будет несколько потоков, несколько не могу обработать сигнал, несколько могут, что будет с сигналом?|обработает рандомный поток их тех, кто может|
|в каком порядке обрабатываются сигналы?|никто не знает, нет гарантий порядка|
|если придет несколько одинаковых сигналов, до того как будет обработка, сколько будет обрабатано?|1|
|можно ли создать гарантии порядка и обработки всех сигналов?|да, сигналы реального времени позволяют сделать это|
