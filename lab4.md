|Вопрос|Ответ|
|------|------|
|как работает pthread_cancel?|pthread_cancel() посылает запрос отмены потоку, который тот может обработать(завершить работу) или проигнорировать.(man pthread_cancel)|
|где обрабатывается запрос?|дефолтно, запрос обрабатывается в функциях(список в man pthreads, есть одна, которая специально для создания cancellation points)(man pthread_cancel)|
|какие недефолтные настройки?|недефолтно, поток может игнорировать запросы pthread_cancel(), тогда они будут копиться в очереди. Еще он можем обрабатывать запросы как можно быстрее, а не только в cancellation points(man pthread_cancel)|
|что делает поток после обработки pthread_cancel?|вызывает функции со стека очистки(pthread_cleanup), вызывает деструкторы для глобалок и статических переменных потока, завершает поток(man pthread_cancel)|
|что за функции очистки?|есть функции pthread_cleanup_pop/push(в pthread_cleanup_push есть аргумент (void* arg), который можно передать в функцию), которые позволяют добавить функции-обработчики на выход из потока(при помощи pthread_cancel, pthread_exit). Отдельную функцию можно вызвать, убрал ее со стека pthread_cleanup_pop(arg), если arg != 0.(man pthread_cleanup_push)|
|что за глобалки и статические переменные потока?|иногда нужно, чтобы глобальный(статические) переменные были локальными для какого-то потока, для этого используется TSD(thread-specific data) area, пространство в памяти потока, изначально пустое, в которое можно добавить данные в виде указателя на данные, также привязав функцию-деструктор. Их можно удалить после. Функции вызовутся после выхода через pthread_cancel или pthread_exit. Ключей ограниченное количество(PTHREAD_KEY_MAX). Когда функция вызывается, она делает свой указатель на свой ключ NULL, если инициализировать в функции заново, это вызовет рекурсию. Glibc обходит такие рекурсии при помощи константы, которая ограничивает количество вызовов функций-деструкторов (man pthread_key_create)|
|как pthread_cancel() переносится в нужный поток?|в структуре потока в ядре есть специальный флаг, значение которого проверяется, чтобы узнать, был ли поток отменен. Сигналы не используются|.
|что будет если в обработчике pthread_cleanup_push добавить еще обработчик?|бесконечная рекурсия, стек оверфлоу(на стек добавляются новые функции, а старые не завершаются)|
|что будет если в обработчике pthread_cleanup_push вызвать pthread_exit?|бесконечная рекурсия, без стек оверфлоу(новых функций не добавляется, только переход на уже существующую)|
